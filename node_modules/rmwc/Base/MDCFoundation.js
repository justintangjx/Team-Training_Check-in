'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withFoundation = exports.deregisterInteractionHandler = exports.registerInteractionHandler = exports.removeClass = exports.addClass = exports.syncFoundationProp = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var React = _interopRequireWildcard(_react);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/************************************************************************
 * Utils
 ***********************************************************************/

/** Copies all known properties from source to target. This is being used in here for class merging. */
var copyProperties = function copyProperties(target, source) {
  var allPropertyNames = Object.getOwnPropertyNames(source).concat(Object.getOwnPropertySymbols(source));

  allPropertyNames.forEach(function (propertyName) {
    if (propertyName.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length|destroy)$/)) {
      return;
    }
    Object.defineProperty(target, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
  });
};

/** Simplifies reduant checks for syncWithProps */
var syncFoundationProp = exports.syncFoundationProp = function syncFoundationProp(prop, foundationValue, callback) {
  if (prop !== undefined && prop !== foundationValue) {
    callback();
  }
};

/************************************************************************
 * Handler Factories
 ***********************************************************************/
var addClass = exports.addClass = function addClass() {
  return function (className) {
    if (!this.state.classes.has(className)) {
      this.safeSetState(function (prevState) {
        return {
          classes: prevState.classes.add(className)
        };
      });
    }
  };
};

var removeClass = exports.removeClass = function removeClass() {
  return function (className) {
    if (this.state.classes.has(className)) {
      this.safeSetState(function (prevState) {
        return {
          classes: prevState.classes.delete(className) ? prevState.classes : prevState.classes
        };
      });
    }
  };
};

var registerInteractionHandler = exports.registerInteractionHandler = function registerInteractionHandler() {
  var refName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'root_';
  return function (type, handler) {
    this[refName] && this[refName].addEventListener(type, handler);
  };
};

var deregisterInteractionHandler = exports.deregisterInteractionHandler = function deregisterInteractionHandler() {
  var refName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'root_';
  return function (type, handler) {
    this[refName] && this[refName].removeEventListener(type, handler);
  };
};

/************************************************************************
 * HOC
 ***********************************************************************/
var withFoundation = exports.withFoundation = function withFoundation(_ref) {
  var FoundationConstructor = _ref.constructor,
      _ref$adapter = _ref.adapter,
      adapter = _ref$adapter === undefined ? {} : _ref$adapter,
      _ref$refs = _ref.refs,
      refs = _ref$refs === undefined ? ['root_'] : _ref$refs;

  var Foundation = function (_React$Component) {
    _inherits(Foundation, _React$Component);

    function Foundation(props) {
      _classCallCheck(this, Foundation);

      var _this = _possibleConstructorReturn(this, (Foundation.__proto__ || Object.getPrototypeOf(Foundation)).call(this, props));

      Object.defineProperty(_this, 'state', {
        enumerable: true,
        writable: true,
        value: {
          classes: new Set()
        }
      });


      _this.foundationRefs = refs.reduce(function (acc, r) {
        // Here we gracefully merge two refs together if one was passed down the chain
        var propName = _this.props.elementRef && _this.props.elementRef.refName_ === r ? 'elementRef' : r;

        acc[r] = function (ref) {
          // React will return a null ref when unmounting which will
          // in turn make our adapters error out. Make sure we only set a ref if its truthy.
          if (ref) {
            _this[r] = ref;
            _this.props[propName] && _this.props[propName](ref);
          }
        };

        // Store the refname on the object so we can reference it later and merge two of the same references together
        acc[r].refName_ = r;

        return acc;
      }, {});

      _this.syncWithProps = _this.syncWithProps.bind(_this);
      return _this;
    }

    _createClass(Foundation, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        this.foundation_ = this.getDefaultFoundation();

        Object.entries(adapter).forEach(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 2),
              handlerName = _ref3[0],
              handler = _ref3[1];

          _this2.foundation_.adapter_[handlerName] = handler.bind(_this2);
        });
        this.foundation_.init();
        this.initialSyncWithDOM();
        this.syncWithProps(this.props);

        // this method should be deprecated in the future in favor of standard refs
        this.props.apiRef && this.props.apiRef(this);
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.foundation_ && this.syncWithProps(nextProps);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.destroy();
      }
    }, {
      key: 'safeSetState',
      value: function safeSetState() {
        this.foundation_ && this.setState.apply(this, arguments);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
        this.foundation_ = undefined;

        // We need to hold onto our refs until all child components are unmounted
        // Here we just wait an extra frame and set them to null so garbage collection will take over.
        window.requestAnimationFrame(function () {
          refs.forEach(function (refName) {
            _this3[refName] = null;
          });
        });
      }
    }, {
      key: 'syncWithProps',
      value: function syncWithProps(nextProps) {}
    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {}

      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       */

    }, {
      key: 'emit',
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var evt = void 0;
        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        var baseName = evtType.split(':').slice(-1).pop();
        var propName = 'on' + baseName.charAt(0).toUpperCase() + baseName.slice(1);

        this.props[propName] && this.props[propName](evt);

        // MDC can change state internally, if we are triggering a handler, resync with our props
        this.syncWithProps(this.props);
      }
    }]);

    return Foundation;
  }(React.Component);

  copyProperties(Foundation.prototype, FoundationConstructor.prototype);

  return Foundation;
};
